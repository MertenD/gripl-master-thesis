\chapter{Quelltexte}\label{ch:quelltexte}

In diesem Anhang sind mehrere Quellcode-Ausschnitte aufgeführt.

\begin{lstlisting}[caption={System-Prompt fuer die DSGVO-Klassifikation von BPMN-Aktivitäten},label={lst:system-prompt}]
You are an expert in analysing Business Process Model and Notation (BPMN) diagrams for GDPR compliance. Your task is to identify and return a list of the IDs of all Activity (Task) elements that process personal data. Ignore all other element types. Always consider every activity in the process; do not omit any activity from your assessment.

Use all available context for each activity - including the activity's name, description, annotations, associated data objects, and message or data associations - to determine whether the activity processes personal data. Under Article 4 of the GDPR, personal data is any information relating to an identified or identifiable natural person, including names, addresses, email addresses, phone numbers, identification numbers, payment or bank details, employment records, academic records, location data, IP addresses, online identifiers, images, audio/video recordings, biometric identifiers, health data or other information that can be linked to a specific person. "Processing" includes any operation performed on personal data, such as collecting, recording, organising, structuring, storing, retrieving, consulting, using, analysing, transmitting, printing, disseminating, aligning, combining, altering, restricting, erasing or destroying the data.

Classify an activity as GDPR-relevant whenever it performs or enables processing of personal data. Indicators include (but are not limited to):

- **Collection and entry of personal data**: Activities that collect or capture personal information, for example entering contact details, addresses, payment information, job applications, health information, student enrolments, membership data, tax declarations, registration forms or other forms with personally identifiable information.
- **Creation, storage and updating of records**: Activities that create, save or update records containing personal data, such as opening customer accounts, storing order or appointment details, creating personnel files, enrolling students, setting up insurance cases or filing a medical record.
- **Transmission or disclosure of personal data**: Activities that send, print or otherwise disclose personal data to another participant, system or third party. Examples include printing shipping labels or prescriptions, sending orders or personal data to logistics partners, pharmacies, insurers or authorities, generating payroll reports for external providers, notifying universities about student records, transmitting tax or social security data, sending confirmations or queries that rely on a person's contact details, or transferring data to non-EU locations.
- **Payments and financial transactions**: Activities that process personal financial data, such as initiating or verifying payments, processing bank account or credit-card information, executing payroll, handling reimbursements or insurance payouts, managing expense claims or collecting membership fees.
- **Use of health, biometric or other special categories of data**: Activities that handle medical diagnoses, prescriptions, insurance claims, disability information, photos of damages or patients, biometric identifiers (fingerprints, facial images, voice), racial or ethnic data, political opinions, religious beliefs or union membership. Processing these "special categories" always triggers GDPR relevance.
- **Audio/Video and communications**: Activities that initiate or join audio or video calls, record calls or meetings, capture surveillance footage, or communicate directly with a data subject via email, chat, SMS or other channels. Simply using a person's contact data to send reminders, marketing messages or notifications is processing.
- **Profiling, scoring and decision-making**: Activities that analyse or evaluate a person's performance, behaviour or characteristics for purposes such as credit scoring, hiring, admissions, insurance underwriting, marketing segmentation, customer value analysis or automated decision-making.
- **Logging, tracking and location data**: Activities that log user activity, record access or usage data, track geolocation (e.g. telematics, fleet or mobile tracking), monitor attendance or timekeeping, or collect IP addresses or device identifiers.
- **Consent and data-subject rights**: Activities that obtain, record or manage consent; respond to requests for access, rectification, restriction, erasure, data portability or objections; or document lawful bases for processing.
- **Deletion, anonymisation or pseudonymisation**: Activities that erase, anonymise or pseudonymise personal data, even if the goal is to remove identifiers, because these operations manipulate personal data.

When assessing an activity, consider synonyms or domain-specific terms: activities referring to customers, patients, applicants, employees, students, voters, taxpayers, residents or members often imply personal data processing, even if names like "address" or "contact" are absent. Use context - data objects, annotations or typical process semantics - to infer personal data involvement. Do not rely solely on explicit data-object links; many process names ("Anmeldung pruefen", "Aufnahmeantrag bearbeiten", "Kundeninfo aktualisieren", "Registrierung bestaetigen", "Kreditwuerdigkeit berechnen") themselves indicate personal data processing.

Do **not** classify an activity as GDPR-relevant when it only performs administrative or logistic tasks that do not involve personal data. Examples include picking or packing goods, routing vehicles without using specific addresses, printing generic pick lists, moving items in inventory, or checking if a document exists without viewing its contents. Likewise, activities using truly aggregated or irreversibly anonymised data can be ignored if no individual can be reidentified.

In your output, return only the IDs of activities you classify as GDPR-relevant. For each, provide a clear explanation in englisch using the activity’s name and description to justify why it processes personal data. Do not reference element IDs in your explanation; use the activity names instead. Exclude from your result any activities that do not process personal data and any elements that are not activity/task elements.
\end{lstlisting}

\begin{lstlisting}[language=Kotlin,caption={Antworttyp fuer die Klassifizierung},label={lst:bpmn-analysis-result}]
data class BpmnAnalysisResult(
    @Description("List of Activity Elements that are classified as relevant for GDPR compliance")
    var elements: List<Element>
) {

    init {
        elements = elements.filter { it.isRelevant }
    }

    @Description("Represents an Activity/Task Element that is classified as relevant for GDPR compliance")
    data class Element(
        @Description("The ID of the Activity Element")
        val id: String,
        @Description("The detailed reason why the Activity Element is relevant for GDPR compliance and why you think personal data is processed.")
        val reason: String,
        @Description("Indicates whether the Activity Element is relevant for GDPR compliance")
        val isRelevant: Boolean = true
    )

    /* Andere Methoden dieser Klasse sind weggelassen */
}
\end{lstlisting}

\begin{lstlisting}[language=Kotlin,caption={Kern der \texttt{id}-Validierung und -Vervollständigung},label={lst:activity-id-resolution}]
fun resolveActivityIds(actualBpmnElements: Set<BpmnElement>): BpmnAnalysisResult {
    val existingActivityIds = actualBpmnElements
        .filter { it.type.lowercase().contains("task") }
        .map { it.id }.toSet()

    val resolvedDistinct = elements.mapNotNull { element ->
        val resolvedId = resolveActivityIdUniquely(element.id, existingActivityIds)
        resolvedId?.let { if (it == element.id) element else element.copy(id = it) }
    }.distinctBy { it.id }

    return BpmnAnalysisResult(elements = resolvedDistinct)
}

private fun resolveActivityIdUniquely(partialId: String, existingActivityIds: Set<String>): String? {
    if (partialId in existingActivityIds) return partialId
    existingActivityIds.filter { it.startsWith(partialId) }.singleOrNull()?.let { return it }
    return existingActivityIds.filter { it.contains(partialId) }.singleOrNull()
}
\end{lstlisting}

\begin{lstlisting}[caption={Schema der YAML-Evaluationskonfiguration},label={lst:evaluation-config-schema}]
{
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$ref": "#/definitions/Configuration",
    "definitions": {
        "Configuration": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "defaultEvaluationEndpoint": {
                    "type": "string"
                },
                "maxConcurrent": { "type": "integer" },
                "repititions": { "type": "integer" },
                "models": {
                    "type": "array",
                    "items": { "$ref": "#/definitions/Model" }
                },
                "datasets": {
                    "type": "array",
                    "items": { "type": "integer" }
                },
                "seed": { "type": "integer" }
            },
            "required": [
                "defaultEvaluationEndpoint",
                "models"
                "datasets",
            ],
            "title": "Configuration"
        },
        "Model": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "label": { "type": "string" },
                "evaluationEndpoint": { "type": "string" },
                "llmProps": { "$ref": "#/definitions/LlmProps" }
            },
            "required": [ "label" ],
            "title": "Model"
        },
        "LlmProps": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
                "baseUrl": {
                    "type": "string",
                    "format": "uri",
                    "qt-uri-protocols": [ "https" ]
                },
                "modelName": { "type": "string" },
                "apiKey": { "type": "string"},
                "timeoutSeconds": { "type": "number" },
                "temperature": { "type": "number" },
                "topP": { "type": "number" },
            },
            "required": [],
            "title": "LlmProps"
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={Zusammengefasster Logauszug zum Retry-Mechanismus}, label={lst:retry-log}]
2025-10-03T19:11:51.152+02:00  INFO  BpmnExtractor  : Extracting BPMN elements from XML

# 1) Erste Anfrage an das LLM (gekuerzt: Prompt/Headers/Body)
2025-10-03T19:11:51.156+02:00  INFO  LoggingHttpClient  : HTTP POST https://openrouter.ai/api/v1/chat/completions
  model: openai/gpt-oss-20b
  messages: [system: (System-Prompt), user: (User-Prompt mit BpmnElement-Liste und Format-Anweisung)]

# 2) Antwort des LLM mit fehlerhaftem JSON (verkuerzt)
2025-10-03T19:11:56.671+02:00  INFO  LoggingHttpClient  : HTTP 200
assistant:
{
  "elements": [
    { "id": "Activity_09ehuii", "reason": "...", "isRelevant": true },
    { "id": "Activity_1la5hsp", "reason": "...", "isRelevant":  }   <-- fehlender Bool-Wert
    { "id": "Activity_0rfgrlm", "reason": "...", "isRelevant": true }
  ]
}

# 3) Parser-Fehler + Retry-Ankuendigung (gekuerzt)
2025-10-03T19:11:56.691+02:00  WARN  SafetyNet  : Parsing failed. Attempting to fix JSON and retry... (Attempt 1 of 2)
dev.langchain4j.service.output.OutputParsingException:
  Caused by: com.fasterxml.jackson.core.JsonParseException:
  Unexpected character ('}') ... at elements[1].isRelevant

# 4) Zweite Anfrage zum beheben des JSON mit Chat-Verlauf und Fehlermeldung (n-mal wiederholt, bis erfolgreich)
2025-10-03T19:11:56.721+02:00  INFO  LoggingHttpClient  : HTTP POST https://openrouter.ai/api/v1/chat/completions
  messages: [
    system: (System-Prompt),
    user: (User-Prompt mit BpmnElement-Liste und Format-Anweisung),
    assistant: (Fehlerhafte JSON-Antwort),
    system: (Fix-JSON System-Prompt),
    user: (Fehlermeldung)
  ]

# 5) Korrigierte JSON-Antwort des LLM
2025-10-03T19:12:01.519+02:00  INFO  LoggingHttpClient  : HTTP 200
assistant:
{
  "elements": [
    { "id": "Activity_09ehuii", "reason": "...", "isRelevant": true },
    { "id": "Activity_1la5hsp", "reason": "...", "isRelevant": true }, <-- jetzt mit Bool-Wert
    { "id": "Activity_0rfgrlm", "reason": "...", "isRelevant": true }
  ]
}

# 6) Erfolgreiches Parsing und Weiterverarbeitung
2025-10-03T19:12:01.519+02:00  INFO  PromptBpmnAnalyzer : BPMN Analysis Result: elements=[... isRelevant=true ...]
\end{lstlisting}

\begin{lstlisting}[caption={Konfigurationsdatei des Experiments mit Gemma Modellen}, label={lst:gemma-experiment-config}]
defaultEvaluationEndpoint: /gdpr/analysis/prompt-engineering
seed: 24523833
maxConcurrent: 10
repetitions: 5
models:
  - label: Gemma-3-12B-it
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: google/gemma-3-12b-it
      apiKey: ${OPEN_ROUTER_API_KEY}
  - label: Gemma-3-27B-it
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: google/gemma-3-27b-it
      apiKey: ${OPEN_ROUTER_API_KEY}
datasets:
  - 2
  - 7
  - 1
\end{lstlisting}

\begin{lstlisting}[caption={Konfigurationsdatei des Experiments mit DeepSeek Modellen}, label={lst:deepseek-experiment-config}]
defaultEvaluationEndpoint: /gdpr/analysis/prompt-engineering
seed: 24523833
maxConcurrent: 10
repetitions: 5
models:
  - label: DeepSeek-V3.1
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: deepseek/deepseek-chat-v3.1
      apiKey: ${OPEN_ROUTER_API_KEY}
  - label: DeepSeek-R1-Distill-Qwen-14B
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: deepseek/deepseek-r1-distill-qwen-14b
      apiKey: ${OPEN_ROUTER_API_KEY}
datasets:
  - 2
  - 7
  - 1
\end{lstlisting}

\begin{lstlisting}[caption={Konfigurationsdatei des Experiments mit Qwen Modellen}, label={lst:qwen-experiment-config}]
defaultEvaluationEndpoint: /gdpr/analysis/prompt-engineering
seed: 24523833
maxConcurrent: 10
repetitions: 5
models:
  - label: Qwen2.5-7B-Instruct
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: qwen/qwen-2.5-7b-instruct
      apiKey: ${OPEN_ROUTER_API_KEY}
  - label: Qwen3-235B-A22B-Thinking-2507
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: qwen/qwen3-vl-235b-a22b-thinking
      apiKey: ${OPEN_ROUTER_API_KEY}
datasets:
  - 2
  - 7
  - 1
\end{lstlisting}

\begin{lstlisting}[caption={Konfigurationsdatei des Experiments mit GPT Modellen}, label={lst:gpt-experiment-config}]
defaultEvaluationEndpoint: /gdpr/analysis/prompt-engineering
seed: 24523833
maxConcurrent: 10
repetitions: 5
models:
  - label: GPT-OSS-20B
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: openai/gpt-oss-20b
      apiKey: ${OPEN_ROUTER_API_KEY}
  - label: GPT-OSS-120B
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: openai/gpt-oss-120b
      apiKey: ${OPEN_ROUTER_API_KEY}
  - label: GPT-4o (2024-11-20)
    llmProps:
      baseUrl: https://openrouter.ai/api/v1
      modelName: openai/gpt-4o-2024-11-20
      apiKey: ${OPEN_ROUTER_API_KEY}
datasets:
  - 2
  - 7
  - 1
\end{lstlisting}
